---
tags:
  - Assignment
---

# SVA AssignmenIFt 0 part 4
Name: Shubh Sharma

## a
### 1
A CNF formula is a conjunction of disjunctions. 

If it has at most 2 clauses let the clauses be $a$ and $b$. Let $a$ be a clause that is non-unit. Then $a$ has at least 2 literals say $t_1$ and $t_{2}$. We now find a satisfying argument for the clause $b$, If it has $\lnot t_1$ as a clause, then set that as true and set $t_2$ as true. Otherwise set a satisfying assignment for $b$ and set $t_1$ as true. 

This satisfies both clauses

### 2
#### $C1 \land C2 \implies R$ holds
This is because either of $c$ or $\bar c$ have to false, if in $C_1$, $c$ is false, one of $a_1 \dots a_n$ have to true for the clause to be satisfied, this would also satisfy $R$, if in $C_{2}$, $\bar c$ is set to false, the one of $b_{1}\dots b_{m}$ is set to true, this would also satisfy $R$.

#### $R \not\Rightarrow C1 \land C2$
This is because when give a clause, $a_{1} \lor a_{2} \dots a_{n} \lor b_{1} \lor b_{2}\dots b_{m}$, if we split it to $a_{1} \lor a_{2} \dots a_{n} \lor c$ and $b_{1} \lor b_{2} \dots b_{m} \lor \bar{c}$ at least one of them will definitely be satisfiable, wlog say $a_1 \dots a_n \lor c$ is satisfiable. This means that $b_1 \dots b_m$ might all be forced to be false, but the extra variable $c$ might also be influenced by the rest of the formula.

### 3
If all of the clauses in horn sat contain at least 1 negative variables, setting everything to false gives a satisfying assignment. The only issue is when the clauses is a single variable that is not negated, but that forces the value of the variable which can be used to simplify the formula.

We can follow this algorithm
- If there are no clauses with exactly 1 single non negated variable, set all the variables in the formula to false.
- If there is such a clause, we set it to true. remove each clause where it was positive as that clause is satisfied, and from all other clauses that have the negation of the variable, remove the variable. If we end up with an empty clause return false, else repeat.

### 4
Any boolean formula can be written in the form 
$$
(\dots(((l_{1} \circ l_{2})\circ l_{3})\circ l_{4}) \dots  l_{n})
$$
where $\circ \in \{ \land,\lor \}$ and $l_i$ are literals

This can be done by first assuming every chain of a particular connective to be left associative and then expanding whenever the chain breaks until the above form is reached (also use associativity whenever helpful).

Now consider a formula $\phi=l_1$ which is a single literal.

If $\alpha\models \phi$ then $\phi \in \alpha$ therefor $\beta \models \phi$ where $\beta  \supset \alpha$. If not, then $\lnot \phi \in \beta$ which leads to an inconsistent set.

Given that this works for all $\phi$ for length $n$, let $\varphi = \phi \circ l$
- $\varphi = \phi \lor l$. If $\alpha \models \varphi$, then $\alpha\models\phi$ or $\alpha\models l$
	- if $\alpha\models \phi$ then $\alpha\subset\beta\models \phi$ by induction so $\beta\models \phi\lor l$ .
	- If $\alpha\models l$ then $\alpha \subset\beta \models l$ by base case.
- $\varphi = \phi\land l$ then $\alpha\models \phi$ and $\alpha\models l$
	- $\alpha\subset\beta\models \phi$ by induction
	- $\alpha\subset\beta\models l$ by base case
	- so $\alpha\subset\beta \models \varphi$ 

## b
### 1
Here is the Z3 code for the formula

```py
variables = [
	[Bool(' x_%s_%s '% (i+1, j+1)) for j in range(4)] 
								   for i in range(2)]

must_sit = [
    Or(        variables[0][0], 
		Or(    variables[0][1], 
		    Or(variables[0][2], 
			   variables[0][3]))),
    Or(        variables[1][0], 
	    Or(    variables[1][1], 
		    Or(variables[1][2], 
		       variables[1][3])))
]

not_both  = [
	Not(And(variables[0][j], 
	        variables[1][j])) for j in range(4)]
not_adj_1 = [
	Not(And(variables[0][j], 
	        variables[1][j+1])) for j in range(3)]
not_adj_2 = [
	Not(And(variables[0][j], 
	        variables[1][j-1])) for j in range(1,4)]

one_place_1_temp = [[Not(And(variables[0][i], variables[0][j])) for j in range(i+1, 4)] for i in range(3)]
one_place_1 = []
for cond in one_place_1_temp:
    one_place_1.extend(cond)

one_place_2_temp = [[Not(And(variables[1][i], variables[1][j])) for j in range(i+1, 4)] for i in range(3)]
one_place_2 = []
for cond in one_place_2_temp:
    one_place_2.extend(cond)

final_cond_temp = [not_both, 
				   must_sit, 
				   one_place_1, 
				   one_place_2, 
				   not_adj_2, 
				   not_adj_1]
final_cond = []
for cond in final_cond_temp:
    final_cond.extend(cond)


print(get_models(final_cond, 1000))

```

### 2

The list of solutions generated by z3 are
```
[[ x_1_4  = False,
  x_2_2  = False,
  x_2_4  = False,
  x_2_3  = False,
  x_2_1  = True,
  x_1_3  = True,
  x_1_2  = False,
  x_1_1  = False], 
  
  [ x_1_4  = True,
  x_2_2  = True,
  x_2_4  = False,
  x_2_3  = False,
  x_2_1  = False,
  x_1_3  = False,
  x_1_2  = False,
  x_1_1  = False], 
  
  [ x_1_4  = False,
  x_2_2  = False,
  x_2_4  = False,
  x_2_3  = True,
  x_2_1  = False,
  x_1_3  = False,
  x_1_2  = False,
  x_1_1  = True], 
  
  [ x_1_4  = False,
  x_2_2  = False,
  x_2_4  = True,
  x_2_3  = False,
  x_2_1  = False,
  x_1_3  = False,
  x_1_2  = False,
  x_1_1  = True], 
  
  [ x_1_4  = False,
  x_2_2  = False,
  x_2_4  = True,
  x_2_3  = False,
  x_2_1  = False,
  x_1_3  = False,
  x_1_2  = True,
  x_1_1  = False], 
  
  [ x_1_4  = True,
  x_2_2  = False,
  x_2_4  = False,
  x_2_3  = False,
  x_2_1  = True,
  x_1_3  = False,
  x_1_2  = False,
  x_1_1  = False]]
```