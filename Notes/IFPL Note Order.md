- [[Denotational Semantics for lambda Calculus]]
- [[Enriched Lambda Calculus]]
- [[let-expressions in Enriched Lambda Calculus]]
- [[let-expressions in Enriched Lambda Calculus]]
- [[Patterns]]
- [[Translating Haskell Programs to Lambda Calculus]]
- [[Translation Scheme from Haskell to Lambda Calculus for Expressions]]
- [[Translation Scheme from Haskell to Lambda Calculus for Definitions]]
- [[Translation Scheme from Haskell to Lambda Calculus for Some RHS only options]]
- [[Evaluating Pattern Matching in Lambda Calculus]]
- [[Match Function for Enriched Lambda Calculus]]
- [[Variable Rule for Match Function]]
- [[Constructor Rule for Match Function]]
- [[Empty Rule for Match Function]]
- [[Mixture Rule for Match Expression]]
- [[Optimisations for Overlapping Patterns]]
- [[Optimisations for Expressions containing FAIL and I>]]
- [[Uniform Definition of Haskell Functions]]
- [[False Assumptions easy to make about Patterns]]
- [[Ordering Equations in Uniform Definitions]]
- [[Independence of meaning from changing the order on the left hand side implies uniform definition]]
- [[Converting Enriched Lambda Calculus to Ordinary Lambda Calculus]]
- [[Pattern Matching to Ordinary Lambda Calculus]]
- [[Constant Pattern to Lambda Calculus]]
- [[Product Constructor Pattern Matching to Lambda Calculus]]
- [[Sum Constructor Pattern Matching to Lambda Calculus]]
- [[let(rec)-expressions to Ordinary Lambda Calculus]]
- [[Dependency analysis for letrec expressions]]
- [[Irrefutable let(rec)]]
- [[Conformality Transformation on let(rec) expressions]]
- [[Irrefutable let(rec)s to Simple let(rec)s]]
- [[letrec-expressions to Irrefurtable let-expressions]]
- [[Simple let expressions to Ordinary Lambda Calculus]]
- [[Converting Case Expressions to Ordinary Lambda Calculus]]